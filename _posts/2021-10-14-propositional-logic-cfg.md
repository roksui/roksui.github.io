---
title: Models of Computation(4) - Context-free Grammars (CFG)
use_math: true
---

### Limitations of Regular Expressions
Regular expressions are useful for basic pattern matching. However, they cannot recognize the set of all Python programs nor all propositional formulas!

### Grammars in a nutshell
- A grammar is a set of rules which can be used to generate/derive strings, and therefore languages. The rules are a recursive description of the strings.
- Grammars naturally describe the hierarchical structure of most programming languages.
- Grammars also form the basis for translating between different representations of programs.

## Context-free grammars
Context-free grammars(CFG) is a mechanism for describing languages.

**Program Syntax**
```
statements: statement+
statement: compound_stmt | simple_stmt
```

**Our Syntax**
$S \rightarrow TS$
$T \rightarrow c|d$

Let us look at an example.
$S \rightarrow 0S1$
$S \rightarrow T$
$T \rightarrow #$

To derive a string:
1. Write down the start variable. It is the variable on the LHS of the top rule, unless specified otherwise.
2. Find a variable that is written down and a rule that starts with that variable. Replace the written down variable with the RHS of that rule.
3. Repeat step 2 until no variables remain.

$$
S \Rightarrow 0S1
  \Rightarrow 0T1
  \Rightarrow 0#1
$$

$$
S \Rightarrow 0S1
  \Rightarrow 00S11
  \Rightarrow 000S111
  \Rightarrow 000T111 \Rightarrow 000#111
$$

These can be examples of string derivation.

### Anatomy of a grammar
- Variables (or Non-terminals)
  - These get rewritten to generate strings
- Start variable
- Alphabet
  - Consisting of terminal symbols making up strings in the language being generated
- Rules of the form $A \rightarrow u$ where $A$ is a variable and $u$ is a string of variables and alphabet symbols.

A variable can have many rules:
$$
S \rightarrow 0S1
s \rightarrow T
$$
which can be written together with the 'or' operator,
$ S \rightarrow 0S1 | T$

Example.
- Variable $S, T$
- Alphabet symbols $0, 1, #$
- Start variable $S$
- Rules:
$$
S \rightarrow 0S1 | T$
T \rightarrow #
$$


$S \Rightarrow 0S1 \Rightarrow 00S11 \Rightarrow 00T11 \Rightarrow 00#11$
We can derive the string $00#11$.

Another Example.
- Variables $E$
- Alphabet symbols $a, b, c, -$
- Start variable $E$
- Rules:
$ E \rightarrow E - E|a|b|c$

We can derive the following strings.

$E \Rightarrow a \Rightarrow b \Rightarrow c$

$$
E \Rightarrow E - E
  \Rightarrow a - E
  \Rightarrow a - a
$$

$$
E \Rightarrow E - E
  \Rightarrow E - E - E
  \Rightarrow E - E - a
  \Rightarrow b - E - a
  \Rightarrow b - c - a
$$

### Notation
- $A, B, C, \ldots \text{ and } S$ are variables.
- $S$ is the start variable.
- $a, b, c, \ldots$ are terminals.
- $u, v, w, \ldots$ are strings of terminals and variables. This can include the empty string $\epsilon$.
- Often we just write the rules.
- The start variable is usually $S$, or the first one listed.

### More Examples
Which natural language description applies to the language generated by the following grammar?
$$
S \rightarrow 0S1|T
T \rightarrow #
$$

=> All strings over alphabet $\{0, 1, #\}$ of the form $0^n#1^n \text{ where } n \geq 0$. Note that it is not $0\*#1\*$ as this could generate $0#11$ which is not desired.

Write a natural language description of the language of the following grammar:
$E \rightarrow E + E | 0 | 1$

=> All binary strings over the alphabet $\{0, 1\}$

### Some thoughts on designing CFGs
1. Think recursively!
  - How can a string in the language be built from smaller strings in the language?
  - Make sure you cover all cases.
2. Variables generate substrings with similar properties.
  - Think of the variables as storing information, or as having meaning.

## Designing CFGs
Q. Design a grammar that generates the language of binary strings that are *palindromes*.

**Think recursively!**
1. Base case: $0, 1, \epsilon$ are palindromes.
2. Recursive case: if $u$ is a palindrome, then $0u0 \text{ and } 1u1$ are palindromes.
  - Why are there no other cases?

So, here is a grammar:
$$
S \rightarrow 0|1|\epsilon
S \rightarrow 0S0|1S1
$$

Q. Design a grammar that generates the language of binary strings with the same number of 0's and 1's.
1. Base case: $\epsilon$ has the same number of 0's and 1's. i.e. none.
2. Recursive case: if $u, v$ have the same number of 0's and 1's, then so do $0u1v \text{ and } 1u0v$.
  - Why are there no other cases?

Here is a grammar:
$$
S \rightarrow \epsilon
S \rightarrow 0S1S|1S0S
$$

Q. Design a grammar that generates the language of binary strings of the form $0^n1^m0^n \text{ for } n, m \geq 0$.

Here is a grammar:
$$
S \rightarrow 0S0|X
X \rightarrow 1X|\epsilon
$$

**NOTE**: The variable $X$ generates the language $L(1\*)$.
i.e.
$$
X \Rightarrow 1X
  \Rightarrow 11X
  \Rightarrow 111X
  \Rightarrow 111\epsilon = 111
$$

## Context-Free Languages
<u>Definition</u>
A language is **context-free** if it is generated by a CFG.

**Easy Facts**
- The union of two CFL is also context-free.
  - Why? Just add a new rule $S \rightarrow S_{1}|S_{2} \text{ where } S_{i}$ is the start symbol of grammar $i$.
- The concatenation of two CFL is also context-free.
  - Why? Just add a new rule $S \rightarrow S_{1}S_{2}$.
- The star(closure) of a CFL is also context-free.
  - Why? Just add a new rule $S \rightarrow SS_{1}|\epsilon$.

### Examples
Show that $L(a\*\cupb\*)$ is context-free.

Note that this is the language $L(a\*) \cup L(b\*)$.

Here is a grammar for $L(a\*) \text{ and } L(b\*)$:

$S_{1} \rightarrow S_{1}a|\epsilon$
$S_{2} \rightarrow S_{2}b|\epsilon$

So here is a grammar for $L(a\*) \cup L(b\*)$:
$$
S \rightarrow S_{1}|S_{2}
S_{1} \rightarrow S_{1}a|\epsilon
S_{2} \rightarrow S_{2}b|\epsilon
$$

Show that $L(a\*b\*)$ is context-free.

Note that this is the language $L(a\*)L(b\*)$.

Similar to above, here is a grammar for $L(a\*)L(b\*)$.
$$
S \rightarrow S_{1}S_{2}
S_{1} \rightarrow S_{1}a|\epsilon
S_{2} \rightarrow S_{2}b|\epsilon
$$

Show that $L((aa|bb)\*) is context-free.

Note that this is the language $L(aa|bb)\*$.

Here is a grammar for $L(aa|bb)$:
$S_{1} \rightarrow aa|bb$

So here is a grammar for $L(aa|bb)\*$:
$$
S \rightarrow S_{1}S|\epsilon
S_{1} \rightarrow aa|bb
$$

**NOTE** that CFGs are not allowed to mention the star operation(*).

## Parsing
The problem of *parsing* is determining how the grammar derives a given string.

A **parse tree** (or derivation tree) is a tree labelled by variables and terminal symbols of the CFG.
- The root is labeled by the start variable.
- Each interior node is labeled by a variable.
- Each leaf node is labeled by a terminal or $\epsilon$.
- The children of a node labeled $X$ are labeled by the RHS of a rule $X \rightarrow x$, in order.

For example, the parse tree for $0011 \text{ in } S \rightarrow 0S1|01$ is as follows:
--ADD IMAGE--

A traversal of the leaf nodes retrieves the string.

The parse tree gives the "meaning" of a string.
--ADD IMAGE--

$$
S \rightarrow S - S
S \rightarrow x|y|z
$$

This parse tree says that the expression means $x - (y - z) \text{ not } ((x - y) - z)$.

### Natural Language Processing (NLP)
$$
\langle Sentence \rangle \rightarrow \langle NounPhrase \rangle\;\langle VerbPhrase \rangle
\langle NounPhrase \rangle \rightarrow \langle ComplexNoun \rangle
\langle NounPhrase \rangle \rightarrow \langle ComplexNoun \rangle\;\langle PrepPhrase \rangle
\langle VerbPhrase \rangle \rightarrow \langle ComplexVerb \rangle|\langle ComplexVerb \rangle\;\langle PrepPhrase \rangle
\langle PrepPhrase \rangle \rightarrow \langle Prep \rangle\;\langle ComplexNoun \rangle
\langle ComplexNoun \rangle \rightarrow \langle Article \rangle\;\langle Noun \rangle
\langle ComplexVerb \rangle \rightarrow \langle Verb \rangle|\langle Verb \rangle\;\langle NounPhrase \rangle
\langle Article \rangle \rightarrow \text{a}|\text{the}
\langle Noun \rangle \rightarrow \text{boy}|\text{dog}|\text{ball}|\text{stick}
\langle Verb \rangle \rightarrow \text{walks}|\text{runs}
\langle Prep \rangle \rightarrow \text{with}
$$

- Terminals are the lower-case English alphabet.
- For variables, we used $\langle Noun \rangle$, etc, for readability.

Now comes the ambiguity though...
The string "the boy walks the dog with the stick" can be derived in this grammar. But it has (at least) two parse-trees depending on who has the stick.

First parse tree:
--ADD IMAGE--

Second parse tree:
--ADD IMAGE--

### Ambiguous grammars and strings
<u>Definition</u>
A string is **ambiguous** on a given grammar if it has at least two different parse trees.
A grammar is ambiguous if it derives an ambiguous string.

So, we can say that the previous grammar is ambiguous.

Is there a way to see if a string is ambiguous without drawing parse trees?
- A derivation is called **leftmost** if it always derives the leftmost variable first.
- Each parse tree corresponds to one leftmost derivation.
- So, a string is ambiguous if it has at least two leftmost derivations.
- The same two statements hold with rightmost instead of leftmost.

So, "The boy walks the dog with a stick" has two leftmost derivations.

$$
\langle Sentence \rangle \Rightarrow text{the boy } \langle VerbPhrase \rangle
\Rightarrow text{the boy } \langle Verb \rangle\;\langle NounPhrase \rangle
\Rightarrow text{the boy chases the dog with a stick}
$$

$$
\langle Sentence \rangle \Rightarrow text{the boy } \langle VerbPhrase \rangle
\Rightarrow text{the boy } \langle ComplexVerb \rangle\;\langle PrepPhrase \rangle
\Rightarrow text{the boy chases the dog with a stick}
$$

Consider the following example. Is the grammar ambiguous?

$$
E \rightarrow E - E
E \rightarrow a|b|c
$$

Rightmost derivations of $a - b - c$:
$$
E \Rightarrow E - E
  \Rightarrow E - c
  \Rightarrow E - E - c
  \Rightarrow E - b - c
  \Rightarrow a - b - c
$$

$$
E \Rightarrow E - E
  \Rightarrow E - E - E
  \Rightarrow E - E - c
  \Rightarrow E - b - c
  \Rightarrow a - b - c
$$

The respective parse trees are:
--ADD IMAGE--
--ADD IMAGE--

What about $a - b$?

Now, suppose we want $a - b - c$ to always mean $(a - b) - c$.
Introduce a new non-terminal symbol $T$:
$$
E \rightarrow E - T|T
T \rightarrow a|b|c
$$

Now, the only rightmost derivation of $a - b - c$ is:
$$
E \Rightarrow E - T
  \Rightarrow E - c
  \Rightarrow E - T - c
  \Rightarrow E - b - c
  \Rightarrow T - b - c
  \Rightarrow a - b - c
$$

--ADD IMAGE--

### Why are they called "context-free"?
The **Chomsky Hierarchy** consists of 4 classes of grammars, depending on the type of production rules that they allow.
Type 0 (recursively enumerable) $z \rightarrow v$
Type 1 (context-sensitive) $uAv \rightarrow uzv$
Type 2 (context-free) $A \rightarrow z$
Type 3 (regular) $A \rightarrow aB \text{ and } A \rightarrow a$
given that $u, v, z$ are string of variables and terminals and $z$ is not empty.

--ADD IMAGE--

## Reference
USYD COMP Lectures, 2021 September