---
title: "Secure Hash Algorithm"
use_math: true
---

## 개요

Secure Hash Algorithm (SHA)는 National Institutes of Standards and Technology (NIST)와 정부 및 개인 연구 그룹에서 개발한 데이터를 보호하기 위한 암호화 알고리즘의 집합이다. 이 알고리즘들은 해시 함수(Hash Function)를 사용하여 데이터를 변환시킨다.

이러한 해시 함수는 여러 과정을 통해 원래의 데이터를 전혀 다른 형태의 문자열로 변환해준다. SHA-1, SHA-2, SHA-3는 각각 점차적으로 강력해지는 암호화를 통해 설계된 알고리즘이다. SHA-0은 현재는 너무나 많은 취약점이 노출되어 퇴화된(obsolete) 상태이다.

SHA의 가장 흔한 응용은 비밀번호를 암호화하는 것이다 - 서버에서 특정 유저의 실제 비밀번호를 저장하지 않고, 해시 값만 저장하면 되기 때문이다. 이를 통해 해커가 데이터베이스를 공격하여도, 해시로 암호화된 문자열만 볼 수 있을 것이다. 또한, SHA는 눈사태 효과(avalanche effect) 속성을 갖는다 - 암호화될 데이터가 조금만 바뀌어도 아웃풋이 크게 바뀌는 것, 혹은 반대로 기존 데이터의 큰 변화는 비슷한 해시 값을 불러오는 것을 말한다. 이러한 속성은 해시 값이 인풋 스트링에 대한 정보를 노출하지 않도록 해준다. 그리고 이러한 효과를 사용하여 공격자가 데이터를 변경했는지도 쉽게 알 수 있다.

## SHA 특징

암호화 해시 함수는 세 가지 근본적인 안전성 특징을 통해 데이터 보안을 책임진다:

1. pre-image resistance
2. second pre-image resistance
3. collision resistance

암호화 기법의 초석은 pre-image resistance를 제공하는 것이다. 이는 다시 말해 공격자가 해시 값 $h_{m}$을 알고 있을 때, 원래의 메시지 $m$을 찾는 것을 매우 어렵게, 혹은 시간이 오래 걸리게 하는 것을 말한다. 이는 one-way function의 특성에 의해 제공되는데, SHA의 핵심 요소라고 볼 수 있다. Pre-image resistance를 통해 강력한 컴퓨팅 파워를 통한 브루트포스 공격을 막을 수 있다.

### One-way Function Example

Alice와 Bob은 우편을 통해 의견을 교환한다. Alice가 Bob을 방문했을 때, 그녀가 사는 도시의 전화번호부를 주었다. 외부자로부터 그들의 메시지를 노출하지 않기 위해 Alice는 Bob에게 메시지를 암호화하겠다고 말하였다. 그녀는 각 편지에 특정 조합의 숫자들이 있을 것이고 각 숫자 시퀀스는 전화번호를 나타낸다고 말한다. Bob은 그 전화번호를 전화번호부에서 찾아서 해당 사람의 성의 첫 문자를 적으면 된다. 이러한 '함수'를 통해 Bob은 전체 메시지를 복호화할 수 있다.

메시지를 복화하하기 위해, Bob은 전체 전화번호부를 읽어서 편지에 있는 모든 숫자들을 찾아야 하지만, Alice는 메시지를 암호화하기 위해 문자를 빠르게 찾아서 그에 해당하는 전화번호를 적기만 하면 된다. 이러한 이유 때문에, Bob이 메시지를 일일이 복화하기 전에, Alice는 메시지를 재암호화하여 데이터를 안전하게 유지할 수 있다. 따라서 Alice의 알고리즘은 one-way function이다. 즉, one-way function은 한 쪽으로 값을 구하는 것은 쉽고 빠르지만, 반대쪽의 값, 즉 inverse 값을 구하는 것은 매우 어렵다. 여기서 쉽고 어렵다의 기준은 계산의 복잡도의 맥락으로 이해할 수 있다.

두 번째 안전성 특징은 second pre-image resistance이다. 이는 하나의 메시지 $m_{1}$을 알고 있을 때, 동일한 해시 값 $H_{m_{1}} = H_{m_{2}}$로 매핑되는 또 다른 메시지 $m_{2}$를 찾기가 어려운 것이다. 이 특징이 없다면 두 개의 다른 비밀번호가 동일한 해시 값으로 매핑되어, 보호된 데이터에 접근하기 위해 원래의 비밀번호가 쓸모없어 지는 것을 의미한다.

마지막 안전성 특징은 collision resistance이다. 이는 공격자가 동일한 해시 값 $H_{m_{1}} = H_{m_{2}}$로 매핑되는 두 개의 완전히 다른 메시지를 찾는 것을 매우 어렵게 만드는 것이다. 이 특징을 제공하기 위해서는 비슷한 개수의 가능한 인풋과 가능한 아웃풋이 있어야 한다. 왜냐하면 인풋이 아웃풋 보다 많으면 비둘기집 원리에 의해 충돌이 무조건 발생하기 때문이다. 따라서 collision resistance가 있다면 동일한 해시 값으로 매핑되는 두 개의 인풋을 찾는 것이 매우 어려워진다. 이러한 특징이 없다면 디지털 서명에 이러한 점을 악용하여 한 사람이 동일한 해시 값으로 두 개의 문서를 서명하였는데, 유저들은 이것이 두 명의 다른 사람에 의해 작성된 두 개의 문서라고 믿을 수 있는 것이다.

일반적인 가이드라인으로 해시 함수는 최대한 랜덤해야하되, deterministic하고 계산이 빠르게 되어야 한다.

## SHA-1

SHA-1은 1993년도에 NIST에 의해 개발되어 TLS, SSL, PGP, SSH, IPsec 및 S/MIME 등의 보안 어플리케이션 및 프로토콜에 광범위하게 사용되었다.

SHA-1은 메시지를 $2^{64}$ bits 이하의 길이의 bit string의 형태로 인풋을 주어 160-bit 해시 값을 제공하는데, 이러한 해시 값을 *message digest*라 부른다. 아래 예시에서는 간결함을 유지하기 위해 hexadecimal로 메시지를 표시하겠다.

SHA-1을 사용하여 메시지를 암호화하는 두가지 방법이 있다. 그중 한 가지 방법은 64개의 32-bit 단어를 처리해야하는 과정을 줄여주지만 실행하기 위해서는 더욱 복잡하고 시간이 걸린다. 아래 예시에서는 더 간단한 방법을 소개한다. 실행이 끝나면 알고리즘은 16개의 단어의 블록들을 아웃풋으로 내보내는데, 각 단어는 16 bits이므로 총 256 bits가 결과로 나온다.

### Pseudocode

메시지 'abc'를 SHA-1로 인코딩한다고 가정해보자.

'abc'는 바이너리 형태로 $01100001\;01100010\;01100011$이다.

**Step 1.** 첫 단계는 다섯 개의 랜덤한 hex 문자들로 구성된 스트링을 초기화하는 것이다. 각각은 해시 함수의 일부분이 될 것이다.

$$
\begin{align}
H_{0} &= 67DE2A01 \\
H_{1} &= BB03E28C \\
H_{2} &= 011EF1DC \\
H_{3} &= 9293E9E2 \\
H_{4} &= CDEF23A9
\end{align}
$$

**Step 2.** 다음으로 메시지 끝에 1을 한개 붙여줌으로써 패딩을 해주고 메시지가 총 448 bits가 될 때 까지 0을 붙여준다. 그리고 메시지의 길이를 64 bits로 나타낸 것을 또 붙여줌으로써 512 bits의 메시지가 나오게 된다.

![sha-1-msg-padding](/assets/img/sha-1-msg-padding.png)

**Step 3.** 위에서 얻은 패딩된 인풋 $M$을 512-bit 블록으로 나누고 각 블록은 한번 더 16개의 32-bit 단어들 $W_{0}, \ldots, W_{15}$로 나눈다. 'abc'의 경우, 메시지가 총 512 bits보다 적기 때문에 오로지 하나의 블록만 있다.

TODO: 2단계에서 512는 항상 맞춰야 하는건가? 아니면 메시지마다 다른건가?

## 출처

<https://brilliant.org/wiki/secure-hashing-algorithms/>
